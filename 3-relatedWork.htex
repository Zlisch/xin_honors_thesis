\chapter{Related Work}\label{chap:relatedWork}
% maybe 3 sections for choregraphy models: functional; (implementation for real use;) core models; exceptions
% - we discuss in terms of how local computation is considered and how important properties such as
% type preservation and progress is influenced by those decisions
some intro ..

\section{Choreography Models}
some intro ..

\subsection{Typing System for Choreography}
Choreography language model can ensure deadlock freedom without using a typing system. 
The property is typically proven through structural induction on the choreography's 
semantics, where an applicable rule always enables reduction, or reduction 
follows by inductive hypothesis \citep{carbone_deadlock-freedom-by-design_2013, cruz2017core, pohjola_kalas_2022}. 
Typing system in this case might still be desired since it can discipline choreography in 
other ways such as correct protocol implementation.

Channel Choreography (ChC) by \cite{carbone_deadlock-freedom-by-design_2013} is a rich 
choregraphy language where a choreography program consists of where a program consists of roles, threads, 
and sessions that implement communication protocols. Deadlock freedom is guaranteed by its 
semantics, while the typing system ensures correct protocol implementation by sessions. 
The typing context includes three components: a service environment $\Gamma$, which stores 
global types for public channels specifying session execution and local expressions (annotated 
with threads); a thread environment $\Theta$, which tracks the roles of threads in each session; and a 
session environment $\Delta$, which stores the types of active sessions.

It ensures that a well-typed choreography, with public channels specified by $\Gamma$ and 
threads assuming roles in $\Theta$, maintains disciplined sessions governed by $\Delta$. 
Additionally, runtime typing introduces a delegation environment to handle changes in 
typing context due to asynchrony or parallelism, ensuring the program adheres to the protocol 
during execution.

When local computation is involved in the choreography, since we cannot solve the halting 
problem in semantics by deciding whether the local computation will terminate, a typing system 
is desired to reassert deadlock freedom. To the best of our knowledge, the closet work to this 
discussion is Pirouette by \cite{hirsch_pirouette_2022}. They assume a substitution model with 
small-step semantics for the local language. Based on a set of admissible typing rules for 
the sake of providing a reasoning ground, their results show that type preservation and progress 
in the local language ensure the same for the choreography language. Their progress result aligns 
with our results, but our local language adopts big-step semantics and thus preservation for 
choreography requires strong normalisation from local language rather than type preservation.

Pirouette is a higher-order functional choreography language with three value types: local 
values, local functions (mapping local values to choreographies), and global functions 
(mapping choreographies to choreographies). This structure enables choreographies to return 
values, forming the basis of its typing system. On the other hand, since neither Kalas or the enriched Kalas has 
return values, our typing system mainly checks for the well-formedness of a choreography within the 
typing environment and if any local computation is involved, we discipline it with its own typing
system in a localised typing environment. Pirouette types its local values in a similar projected
typing environment, binding variables to types at a specific location.
% maybe an example

% There is also an interesting observation between Pirouette and Kalas in terms of how asynchronous 
% behaviours are controlled. Pirouette uses a set of blocked locations to disallow a branching from 
% current choregraphy in which multiple attempts to write to one target local variable may occur
% in different orders, whereas Kalas uses an action label to record previous communication to 
% disallow a branching where the target local variable is appear in the label.
% might be incorrect

Another state-of-art functional choregraphy language Chor$\lambda$ by \cite{cruz-filipe_functional_2022}
uses a different approach than Pirouette, where choreographies are interpreted as terms in 
$\lambda$-calculus. Chor$\lambda$ assumes local values for communications, without focusing 
on how they are computed. This results in a distinct typing system: local value types are 
annotated with roles and are part of the global types, rather than being projected from 
a global environment. Type preservation and progress follow from Chor$\lambda$'s typing 
and semantic rules.

\subsection{Implementation and Handling Exceptions}
% choreography in implementation? how they deal with local computations
% Other choreography languages ... and exceptions ...
- Choral: an object-oriented choregraphy implemented as a java library \citep{giallorenzo2024choral}. 
It treats choregraphy as class and EPP as generating role classes from the choregraphy
implementation. It also offloads the local computation to Java. Higher-order functional
choreography models such as Pirouette and Chor$\lambda$ can be viewed as formal model candidates for it.
Its type checker is similar to the typing system in ChC where it has types for public channels
where roles for sender and receiver are specified as well as the type of messages being communicated
an it also has local types annotated with roles.

In terms of communication failure which may raise an exception when a role is trying to perform operation
based on reading from the place where a received message has not arrived yet, Choral implements the failure 
model in RC by \cite{montesi2017choreographies}, using recover strategies such as capped attempts or 
timer within java try-catch block.

- RC, a model where communication failure is considered, recover strategy for senders and receivers, either 
while loop until received (exactly once delivery for setting 1), or with a timer or capped tries (best efforts);
typing system to ensure almost once delivery (and exactly one delivery where message won't be lost);
they use configuration where sender and receiver have stacks and it is initially false, with payload value,
or ticked meaning no longer in the stack (sent/received) to implement send/received and the failure rules for
semantics and typings; we do not consider message sending failure, but we do have exception caused by 
local computation failure (e.g. division by zero) or bad message value type (not a string), and we
record the exception using transition labels. But we do not consider any recover strategy and always
transits the choregraphy into a termination state (nil)

\section{Some Title}
- functional big-step semantics

- SN for STLC; strong normalisation for languages of environmental semantics

