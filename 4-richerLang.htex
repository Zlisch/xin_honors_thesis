\chapter{\richerlang: A Simply Typed Lambda Calculus}\label{chap:richerLang}
We introduce \richerlang, a language over expressions that closely resembles a 
simply typed lambda calculus. We adopt the functional big-step semantics described by 
\cite{owens2016functional}, which guarantees that our evaluation function is both total 
and deterministic. Our implementation includes an evaluation function that utilises clocks 
to evaluate expressions, yielding either values or exceptions. We also account for common 
exceptions, such as division by zero and improperly formatted strings during integer-string 
conversions.

We use an environment, denoted as $\HOLFreeVar{E}$, to store values for free variables. 
Thus we need to pass $\HOLFreeVar{E}$ as an argument to our evaluation function.
While a substitution model may be mathematically appealing, our environment-based approach 
aligns well with functional big-step semantics and is relatively easy to implement. This setup 
leads us to define a typing environment, $\HOLFreeVar{G}$, which stores types for free variables. 
Consequently, expressions in \richerlang{} are always typed within some typing environment.

When it comes to formalising the type soundness statement for \richerlang, we want to ensure that a typed 
expression is evaluated in a \emph{correct} environment $\HOLFreeVar{E}$ according to the typing environment $\HOLFreeVar{G}$
that types the expression, rather than an arbitrary one. To achieve this, 
we define \HOLtm{envtype G E} to characterise such a \emph{correct} environment 
$\HOLFreeVar{E}$ in relation to a typing environment $\HOLFreeVar{G}$.

\section{Syntax}\label{sec:envSyntax}
\begin{definition}[\richerlang\;syntax] \emph{Values} and \emph{expressions} in \richerlang, ranged
over by $v, e$, are inductively defined by the grammar
\begin{center}
\begin{tabular}{rcl}
      $v$ & ::= & $\HOLtm{IntV n} \mid \HOLtm{StrV s} \mid \HOLtm{BoolV b} \mid \HOLtm{Clos s e E} \mid \HOLtm{PairV v1 v2} \mid \HOLtm{SumLV v} \mid \HOLtm{SumRV v}$ \\[1ex]
      $\HOLFreeVar{bop}$ & ::= & $\HOLConst{Add} \mid \HOLConst{Concat} \mid \HOLConst{Mult} \mid \HOLConst{Div} \mid \HOLConst{Mod} \mid \HOLConst{Less} \mid \HOLConst{And} \mid \HOLConst{Or} \mid \HOLConst{Eq} \mid \HOLConst{Sub} \mid \HOLConst{Pair}$ \\[1ex]
      $\HOLFreeVar{uop}$ & ::= & $\HOLConst{Not} \mid \HOLConst{NumOf} \mid \HOLConst{StrOf} \mid \HOLConst{Fst} \mid \HOLConst{Snd} \mid \HOLConst{SumL} \mid \HOLConst{SumR}$ \\[1ex]
      $e$ & ::= & 
          \begin{tabular}[t]{llcll}
            $\HOLtm{Var x}$ & \textit{(var)}
            &  & $\HOLtm{StrLit s}$ & \textit{(str)} \\
            $\HOLtm{IntLit n}$ & \textit{(int)}
            &  & $\HOLtm{BoolLit b}$ & \textit{(bool)} \\
            $\HOLtm{BinOp bop e1 e2}$ & \textit{(bop)}
            &  & $\HOLtm{Uop uop e}$ & \textit{(uop)} \\
            $\HOLtm{If bg e1 e2}$ & \textit{(if)}
            &  & $\HOLtm{Let x e1 e2}$ & \textit{(let)} \\
            $\HOLtm{Fn x e}$ & \textit{(fn)} 
            &  & $\HOLtm{App e1 e2}$ & \textit{(app)} \\
            $\HOLtm{Case e x e1 y e2}$ & \textit{(case)}
            &  &  &
          \end{tabular}
\end{tabular}
\end{center}
\end{definition}
%% TODO add results

\HOLtm{Var x} represents a variable where $\HOLFreeVar{x}$ is 
the string that represents variable's name. \HOLtm{BinOp bop e1 e2} represents
a binary operation and \HOLtm{Uop uop e} represents unary operation.
We include literals for string, integer and boolean in our syntax to allow expressions 
such as \HOLtm{BinOp Add (Var x) (IntLit 1)}.
$\HOLConst{If}$, $\HOLConst{Let}$, $\HOLConst{Fn}$, and $\HOLConst{App}$ are standard.
\HOLtm{Case e x e1 y e2} represents a sum case expression, where the bound variable $\HOLFreeVar{x}$ 
and expression $\HOLFreeVar{e1}$ correspond to the 
left branch, while the bound variable $\HOLFreeVar{y}$ and $\HOLFreeVar{e2}$ correspond to the 
right branch. Free variables for \richerlang{}' expressions
are standard.

We separate the syntax definitions for binary and unary operations from the 
concrete definitions of specific binary and unary operators. This makes it 
easy to extend the set of operators: to add a new operator, we only need to 
update the $\HOLFreeVar{bop}$ or $\HOLFreeVar{uop}$ definitions and provide 
the corresponding evaluation rule. This approach also significantly reduces 
the number of cases in proofs that depend on the syntactic structure of expressions, 
as there's just a single case for all binary operators and a single case for 
all unary operators.

We include exceptions to handle division by zero and bad formatted integer strings.
They are thrown by the corresponding operators. We define three observable evaluation results:
as either values, or we encounter a type error (for example, \HOLtm{BinOp Add (IntLit 1) (StrLit "1")}),
or we reach an exception, or the evaluation times out for the given clock value.

We include exceptions to handle cases like division by zero and improperly 
formatted integer strings, which are raised by the relevant operators. We define 
four observable outcomes for evaluation: a successful value $\HOLFreeVar{v}$, a 
\HOLtm{TypeError} for evaluating expressions like \HOLtm{BinOp Add (IntLit 1) (StrLit "1")}, 
an exception \HOLtm{Exn exn}, or a \HOLtm{Timeout} if the evaluation exceeds the 
specified clock limit.

\section{Statics}\label{sec:sstatics}
Our typing rules for expressions closely follow those of a simply typed lambda 
calculus. Because values are not part of the expression syntax, we also define 
a separate typing relation for values.

% maybe a formal description of G's syntax
Our expressions are typed in a typing environment $\HOLFreeVar{G}$ which 
stores mappings from variable names to types. Similar to a variable expression
is evaluated by looking up variable name in the given environment $\HOLFreeVar{E}$,
a variable expression is typed by looking up type stored under the variable
name in the given typing environment $\HOLFreeVar{G}$. This setup, requires
us to constrain the typing environment $\HOLFreeVar{G}$ and dynamic environment
$\HOLFreeVar{E}$ in the type soundness statement to make sure we are
evaluating the typed expression using a correct dynamic environment that
aligns with the typing constrain specified in $\HOLFreeVar{G}$. 

Our expressions are typed within a typing environment, $\HOLFreeVar{G}$, 
which maps variable names to types. Just as a variable expression is evaluated 
by looking up its variable name in the dynamic environment $\HOLFreeVar{E}$, a variable expression
is typed by checking the type associated with that variable name in the typing 
environment $\HOLFreeVar{G}$. This setup requires the dynamic environment $\HOLFreeVar{E}$ 
to be aligned with the types specified in the typing environment $\HOLFreeVar{G}$ in 
the type soundness statement, so we can ensure expressions are evaluated in a correct 
environment.  We formalise this constrain in Section~\ref{subsubsec:senvtypedef}.

For typing binary and unary operations, we delegate the task of 
checking operand types against a specific operator to two external typing relations, 
$\HOLConst{boptype}$ and $\HOLConst{uoptype}$. This approach allows us to define just 
two general rules for binary and unary operations when specifying typing rules for expressions. 
This results in fewer cases in the type soundness proof for operators, 
requiring only two separate soundness lemmas for $\HOLConst{boptype}$ and $\HOLConst{uoptype}$. 
Our design showcases a clear separation of concerns.

\subsection{Syntax and Typing Rules}\label{subsec:envTypingRules}
\begin{definition}\label{def:stypes}
    - types
\end{definition}

\begin{definition}\label{def:typecheck}
    - typing relations: typecheck
\end{definition}
- typing relations: typecheck, value_type, uop_type, bop_type

\subsubsection{Expressions}
Typing statements for expressions are formulated as \HOLtm{typecheck G e t}, 
where $\HOLFreeVar{t}$ is the type of expression $\HOLFreeVar{e}$ given the typing 
environment $\HOLFreeVar{G}$. A variable $\HOLFreeVar{x}$ is typed by 
looking it up in $\HOLFreeVar{G}$. The typing rules for other expressions are standard.

To type a binary operation \HOLtm{BinOp bop e1 e2}, we need the types of $\HOLFreeVar{e1}$ 
and $\HOLFreeVar{e2}$, given $\HOLFreeVar{G}$, to satisfy the constraints defined by  
$\HOLConst{boptype}$ for the operator $\HOLFreeVar{bop}$. The typing rules for unary 
operations are defined in a similar manner.

\subsubsection{Environments}\label{subsubsec:senvtypedef}
Before we define types for values, we first introduce \HOLtm{envtype G E} as a 
typing constraint that relates the typing environment $\HOLFreeVar{G}$ to the 
dynamic environment $\HOLFreeVar{E}$. Specifically, $\HOLtm{envtype G E}$ requires 
that the values of variables stored in $\HOLFreeVar{E}$ conform to the types of  
variables specified in $\HOLFreeVar{G}$.

\begin{definition}\label{def:envtype}
    - envtype definition.
\end{definition}

\subsubsection{Values}
\begin{definition}\label{def:value_type}
    - typing relations: value_type
\end{definition}

In \HOLtm{value_type v t}, a value $\HOLFreeVar{v}$ is related to a type 
$\HOLFreeVar{t}$. Literal value cases are obvious. Typings for pair and sum values are standard. 
Closure value, represented as \HOLtm{Clos s e E}, is a triple $(\HOLFreeVar{s}, \HOLFreeVar{e}, \HOLFreeVar{E})$ 
corresponding to a function expression \HOLtm{Fn s e}. In this closure, $\HOLFreeVar{s}$ represents the function parameter, 
$\HOLFreeVar{e}$ is the function body, and $\HOLFreeVar{E}$ is the environment that stores the 
bindings of free variables when the function definition is evaluated.

To type a closure value \HOLtm{Clos s e E}, if $\HOLFreeVar{G}$ accurately 
describes the types of variable values stored in $\HOLFreeVar{E}$, we require 
that $\HOLFreeVar{e}$ has the output type $\HOLFreeVar{t2}$ in \HOLtm{G|+(s,t1)}. 
The constraints for $\HOLFreeVar{G}$ and $\HOLFreeVar{E}$ align with Definition~\ref{def
}.
\footnote{We do not apply $\HOLtm{envtype G E}$ directly in the closure case because 
the definition of $\HOLtm{envtype}$ depends on $\vdash_s$, and we want to avoid mutually 
recursive definitions between a definition and a relation in HOL4.}

Requiring the constraint $\HOLtm{envtype G E}$ in the definition of 
\HOLtm{value_type (Clos s e E) (fnT t1 t2)} is appropriate because, when the closure 
value is applied, $\HOLFreeVar{e}$ will be evaluated in the extended closure environment 
\HOLtm{E|+(s,v)} for some argument value $\HOLFreeVar{v}$. Therefore, we want to have $\HOLFreeVar{e}$ 
typed within a typing environment that accurately describes the types of values 
stored in \HOLtm{E|+(s,v)}. As we will see in Section~\ref{subsec
}, the constraint $\HOLtm{envtype G E}$ is also necessary for the proof of the \HOLtm{App e1 e2} 
case in the type soundness proof.

As a consequence of Definition~\ref{def:value_type} and~\ref{def:typecheck}, \HOLtm{SumLV v} 
does not have a unique type because $\HOLFreeVar{t2}$ is arbitrary, 
and the same applies to \HOLtm{SumRV v}. Furthermore, the function \HOLtm{Fn s (Var s)} 
also has non-unique types, as the variable $\HOLFreeVar{s}$ can take on arbitrary types.

\subsection{Typing Examples}
Example~? discussed in Section~? to show our function closure supports 
currying can be typed using the rules in Definition~?. A derivation tree is 
provided in Appendix~?. 

However, the recursion program (Example~?) discussed earlier cannot be typed.
Since it is a let expression, the last rule applied must be T-let. We can
type $\HOLFreeVar{f}\;1$ in the extended typing environment (f:int->int). But 
we cannot type the definition (fn ... some complex expression) in the empty
typing environment since $\HOLFreeVar{f}$ is free in the definition expression.
A stuck derivation tree is provided in Appendix~?.

\section{Dynamics}\label{sec:sdynamics}
We adopt a functional big-step semantics. As a result, our 
semantics are implemented as an evaluation function that takes a clock value $\HOLFreeVar{c}$,
an environment $\HOLFreeVar{E}$, and an expression $\HOLFreeVar{e}$ as inputs. 
We use clocks since the size of expressions are decreasing except for the application 
case, so decreasing the clock value when evaluation an application ensures the termination
of our evaluation function. Our definition of evaluation function also implies a call-by-value
evaluation strategy.

We define the evaluation function as:

\begin{definition}\label{def:sdynamicsrules}
    - semantics rules
\end{definition}

%% TODO somewhere define E
Rules for $\HOLConst{If}$, $\HOLConst{Let}$, and $\HOLConst{Case}$ are standard. 
We evaluate \HOLtm{Var x} by looking up the variable $\HOLFreeVar{x}$ in the provided 
environment $\HOLFreeVar{E}$. If $\HOLFreeVar{E}$ does not contain a binding for $\HOLFreeVar{x}$, 
it indicates that $\HOLFreeVar{x}$ is an undefined variable. Thus \HOLtm{TypeError} is returned.

%% TODO: add appendix
For \HOLtm{Bin bop e1 e2}, we first evaluate $\HOLFreeVar{e1}$ and $\HOLFreeVar{e2}$ 
to obtain $\HOLFreeVar{v1}$ and $\HOLFreeVar{v2}$. Next, we use \HOLtm{eva_bop bop v1 v2} 
to compute the result based on the specific rule for the operator $\HOLFreeVar{bop}$, which is 
defined in $\HOLConst{eval_bop}$. The evaluations for unary operations are defined in a 
similar manner. The definitions of $\HOLConst{eval_uop}$ and $\HOLConst{eval_bop}$ can be 
found in Appendix~?.

Based on the rules outlined so far, let's consider an evaluation example of the expression 
\HOLtm{Uop NumOf (Var x)}. The function \HOLtm{eval_exp c E (Uop NumOf (Var x))} will first 
compute \HOLtm{eval_exp c E (Var x)} by looking up the variable $\HOLFreeVar{x}$ in the 
environment $\HOLFreeVar{E}$. If $\HOLFreeVar{x}$ is not found in $\HOLFreeVar{E}$, the function 
will return \HOLConst{TypeError}. If the lookup 
succeeds, \HOLtm{eval_exp c E (Var x)} will return a value $\HOLFreeVar{v}$, and we will then 
compute \HOLtm{eval_uop NumOf v}. If $\HOLFreeVar{v}$ is not a correctly formatted integer string 
(for instance, if it contains a non-numeric character), \HOLtm{eval_uop NumOf v} will return 
\HOLtm{Exn BadStr}. Otherwise, \HOLtm{eval_uop NumOf v} will return the converted integer value 
\HOLtm{IntV n}. The relevant format checking and string conversion algorithms are utilised by 
$\HOLConst{eval_uop}$ during the evaluation process.

\subsection{Function Closure}\label{subsec:sfunclos}
We first define \HOLtm{DRESTRICT f s} as:

\begin{definition}\label{def:derestrict}
    - definition of $\HOLConst{DRESTRICT}$
\end{definition}

Then we give the evaluation rule for \HOLtm{Fn s e}:

\begin{definition}
    - function semantics rule (restricted version)
\end{definition}

% For a function \HOLtm{Fn s e}, closure \HOLtm{Clos s e E} is a triple
% $(\HOLFreeVar{s}, \HOLFreeVar{e}, \HOLFreeVar{E})$. $\HOLFreeVar{s}$
% is the function parameter. $\HOLFreeVar{e}$ is the function body. 
% $\HOLFreeVar{E}$ is the environment that stores bindings of free variables
% when the function definition is evaluated.

However, our rule stores a restricted environment \HOLtm{Clos s e (DRESTRICT E (free_vars e) \\ s)} 
in the evaluated closure, which may seem unexpected. Nonetheless, we argue that 
\HOLtm{Clos s e (DRESTRICT E (free_vars e) \\ s)} behaves the same as \HOLtm{Clos s e E} during 
evaluations and will produce the same result.

First, \HOLtm{DRESTRICT E (free_vars e)} includes values for all free variables in $\HOLFreeVar{e}$. 
Second, excluding $\HOLFreeVar{s}$ is safe because when we apply the restricted closure to a value, 
we always bind $\HOLFreeVar{s}$ to the argument value. So the previous value of $\HOLFreeVar{s}$ 
stored in the environment becomes irrelevant. This modification is also necessary to preserve 
Proposition~\ref{prop:transsubmap}. Further discussions can be found in Section~\ref{subsec:largerState}.

By using a closure, we can keep track of the values for bound variables in 
nested function definitions. If we do not record the environment when a function 
definition is evaluated, we risk losing the bindings for all other bound variables 
from outer scopes once we complete the evaluation of the innermost function definition. 
Additionally, currying would be impossible without utilising a closure, as illustrated 
in Example~\ref{ex:curryingfailswoutclos}.

\begin{example}\label{ex:curryingfailswoutclos}
    - example: failure without closure
\end{example}

%% TODO use gpt to check it
When we are evaluating $\HOLConst{Fn}\;\HOLFreeVar{y}\;(\HOLConst{Add}\;(\HOLConst{Var}\;\HOLFreeVar{x})\;(\HOLConst{Var}\;\HOLFreeVar{y}\;1))$
in line 5 we know $\HOLFreeVar{x}$ is bound to $1$. But we lose this information
when we choose $(\HOLFreeVar{y}, \HOLConst{Add}\;(\HOLConst{Var}\;\HOLFreeVar{x})\;(\HOLConst{Var}\;\HOLFreeVar{y}))$
to be the evaluation result. So we only know $\HOLFreeVar{y}$ is bound to $\HOLConst{IntLit}\;2$
when we try to evaluate $\HOLConst{Add}\;(\HOLConst{Var}\;\HOLFreeVar{x})\;(\HOLConst{Var}\;\HOLFreeVar{y}\;1)$ in line 7.

By using function closure to record values of all bound variables when a
function definition is being evaluated, we are able to evaluate $\HOLConst{Add}\;(\HOLConst{Var}\;\HOLFreeVar{x})\;(\HOLConst{Var}\;\HOLFreeVar{y}\;1)$,
as illustrated in line 7 of Example~\ref{ex:rescurryingeval}. It is possible that a function body
contains unbound free variables, but such expression cannot be typed in an empty
environment and it is reasonable to make its evaluation fails. Discussions
on typing for function closure are in Section~?.

\begin{example}\label{ex:rescurryingeval}
    - restricted currying evaluation example
\end{example}

\subsubsection{Recursion}
%% TODO needs to be fixed; it breaks references somehow
\richerlang's syntax supports recursion, as one can write a $\HOLFreeVar{Y}$ combinator 
% \begin{HOLmath}
%     \HOLinline{\HOLConst{Fn}\;\HOLFreeVar{f}
% \;\;(\HOLConst{App}\;(\HOLConst{Fn}\;\HOLFreeVar{x}\;(\HOLConst{App}\;(\HOLConst{Var}\;\HOLFreeVar{f})\;(\HOLConst{App}\;(\HOLConst{Var}\;\HOLFreeVar{x})\;(\HOLConst{Var}\;\HOLFreeVar{x}))))
% \;\;\;\;\;(\HOLConst{Fn}\;\HOLFreeVar{x}\;(\HOLConst{App}\;(\HOLConst{Var}\;\HOLFreeVar{f})\;(\HOLConst{App}\;(\HOLConst{Var}\;\HOLFreeVar{x})\;(\HOLConst{Var}\;\HOLFreeVar{x})))))}.
% \end{HOLmath}
However, \HOLtm{Let f e1 e2} does not support recursion because $\HOLFreeVar{f}$ is not bound 
within $\HOLFreeVar{e1}$. Additionally, our typing system is unable to type the $\HOLFreeVar{Y}$ combinator.

We propose that recursion can be easily and effectively integrated into \richerlang{} 
by introducing the syntax $\HOLConst{Letrec}$. The expression 
$\HOLConst{Letrec}\;\HOLFreeVar{f}\;\HOLFreeVar{s}\;\HOLFreeVar{e1}\;\HOLFreeVar{e2}$ will be 
evaluated into a quadruple $(\HOLFreeVar{f}, \HOLFreeVar{x}, \HOLFreeVar{e}, \HOLFreeVar{E})$. 
This quadruple is similar to the one described by \cite{hardin2021concepts}.

\subsection{Main Properties}
Functional big-step semantics ensures that our evaluation function is total and deterministic 
by design. With this in mind, we define the evaluation of an expression as \emph{terminating} 
if there exists a clock value for which the evaluation function returns a result that is not 
$\HOLConst{Timeout}$. Conversely, if the evaluation returns $\HOLConst{Timeout}$ for all clock 
values, we say that the evaluation of the expression \emph{diverges}.

The evaluation of \richerlang{} is also deterministic in the sense that if the evaluation for an 
expression terminates with an initial clock value, then increasing the clock will always yield the 
same result. We demonstrate this result as a corollary that follows from Lemmas~\ref{lem:clock_value_increment},~\ref{lem:clock_exn_increment}, and~\ref{lem:clock_typeerr_increment}.

The first lemma states that if the expression $\HOLFreeVar{e}$ evaluates to a 
value $\HOLFreeVar{v}$ in the environment $\HOLFreeVar{E}$ with a clock value 
$\HOLFreeVar{c0}$, then evaluating the same expression in the same environment 
with a larger clock value $\HOLFreeVar{c1}$ will also yield the same value $\HOLFreeVar{v}$. 
The statements for Lemmas~\ref{lem:clock_exn_increment} and~\ref{lem:clock_typeerr_increment} are analogous.

%% TODO: the appendix label
\begin{lem}\label{lem:clock_value_increment}
  \begin{HOLmath}
    \HOLthm{envSem.clock_value_increment}
  \end{HOLmath}
\end{lem}

\emph{Proof:} Using the well-founded lexicographic induction principle by Definition~\ref{def:sdynamicsrules}, results for 
each case directly follows the inductive hypotheses. The induction principle can be found in Appendix~?. \hfill \(\square\)

\begin{lem}\label{lem:clock_exn_increment}
    - clock_exn_increment
\end{lem}

\emph{Proof:} The proof relies on the same induction principle for Lemma~\ref{lem:clock_value_increment}
and depends on Lemma~\ref{lem:clock_value_increment}, since in the inductive case an exception can occur
after a value. \hfill \(\square\)

% We use the same induction principle in Lemma~\ref{lem:clock_value_increment} proof. 
% Base cases are trivial since by Definition~\ref{def:sdynamicsrules} variables \HOLtm{Var x} or literals 
% such as \HOLtm{IntLit 1} cannot be evaluated into an exception. For the inductive case, when any of the sub-expressions of
% the current expression evaluates into an exception under the initial clock $\HOLFreeVar{c0}$, 
% by the inductive hypothesis we know this sub-expression also evaluates into an exception
% under the bigger clock $\HOLFreeVar{c1}$, which then by the use of monadic binds in Definition~\ref{def:sdynamicsrules},
% the evaluation of the current expression returns an exception. When all the sub-expressions of
% the current expression evaluates into values under the initial clock $\HOLFreeVar{c0}$, we know from the premise 
% of the goal that it is the final evaluation step that uses the evaluated values under the initial clock $\HOLFreeVar{c0}$
% that throws an exception. For example, in the \HOLtm{App e1 e2} case, the premise of the goal gives us
% \HOLtm{eval_exp c0 E e1 = Value (Clos s e E')}, \HOLtm{eval_exp c0 E e2 = Value v}, and
% \HOLtm{eval_exp (c0 − 1) (E' |+ (s,v)) e = Exn exn}. We have \HOLtm{eval_exp c1 E e1 = Value (Clos s e E')} and \HOLtm{eval_exp c1 E e2 = Value v}
% by Lemma~\ref{lem:clock_exn_increment}, and the last evaluation corresponds to the inductive hypotheses for $(\HOLFreeVar{c0}-1, \HOLFreeVar{e})$. 
% Then by applying the inductive hypothesis we have \HOLtm{eval_exp (c1 − 1) (E' |+ (s,v')) e = Exn exn}. Similar analyses apply
% to other inductive cases. \hfill \(\square\)

\begin{lem}\label{lem:clock_typeerr_increment}
    - clock_typeerr_increment
\end{lem}

\emph{Proof:} Similar to the proof for Lemma~\ref{lem:clock_exn_increment}. \hfill \(\square\)

\begin{cor}\label{cor:clockincre}
    - clock_increment
\end{cor}

\emph{Proof:} Cases analyses based on the syntax form of $\HOLFreeVar{r}$. Each case follows either
Lemma~\ref{lem:clock_value_increment},~\ref{lem:clock_exn_increment}, or~\ref{lem:clock_typeerr_increment}. \hfill \(\square\)

Corollary~\ref{cor:clockincre} is important for the proof of strong normalisation. For example, in the 
case of the if statement, we know that the evaluation of the boolean guard and 
the two branches terminates by the inductive hypotheses for their respective clocks. 
We need to ensure that there exists a common clock value on which the evaluation of 
all three expressions also terminates and returns the same results. Further discussion 
on the use of Corollary~\ref{cor:clockincre} in the strong normalisation proof can be found in Section~\ref{subsec:snproof}.

\section{Type Soundness}
\subsection{Lemmas}\label{subsec:envTypingProperties}
We will discuss several lemmas and propositions for the proposed semantics 
and typing rules before proceeding with the type soundness proof.

Our type soundness proof is similar to the type soundness proof for a 
simply typed lambda calculus by \cite{pierce2002types} in a sense
that we require, or at least require an equivalent version of, the generation lemma,
the lemma of canonical forms of types, and the type preservation under 
substitution lemma used in \cite{pierce2002types}'s proof.

Our type soundness proof is similar to the type soundness proof 
for a simply typed lambda calculus with small-step semantics and the substitution 
model, such as the one presented by \cite{pierce2002types}. Specifically, we require, or at 
least need an equivalent version of, the generation lemma, the lemma on canonical 
forms of types, and the lemma on type preservation under substitution, all of which 
are utilised in \cite{pierce2002types}'s proof.

\begin{lem}\label{lem:sgeneration}
    - typecheck_*_thm: the generation lemma
\end{lem}

\emph{Proof:} Immediately follows from Definition~\ref{def:typecheck}. \hfill \(\square\)

The generation lemma enables us to advance one step in the type derivation tree from 
the bottom to the top. It allows us to obtain types and typing information for 
the sub-expressions within a well-typed expression.

\begin{lem}\label{lem:canvaluetype}
    - valuetype_EQ_*: the lemma of canonical forms of types (only useful cases)
\end{lem}

\emph{Proof:} Immediately follows from Definition~\ref{def:sn_v}. \hfill \(\square\)

The canonical form lemma provides the concrete syntax of a value $\HOLFreeVar{v}$ 
along with the typing information for the expressions involved in that concrete syntax, 
given that we have \HOLtm{value_type v t}. This is particularly useful for inductive 
cases in the type soundness proof, as the inductive hypothesis tells us 
that expressions evaluate to a value $\HOLFreeVar{v}$ and that \HOLtm{value_type v t} 
holds. Moreover, the concrete syntax of $\HOLFreeVar{v}$ always aligns with the expressions in goal.

The type preservation under substitution lemma used by \cite{pierce2002types} 
states that substituting variables with terms of appropriate types preserves the original 
type. Since we evaluate variables by looking them up in an environment $\HOLFreeVar{E}$, 
the concept of \HOLtm{envtype G E} (as defined in Definition~\ref{def:envtype}) is 
analogous to the type preservation under substitution lemma.

As discussed in Section~\ref{subsec:envTypingRules} and Section~\ref{sec:sdynamics}, 
we first evaluate the argument expressions into values, and then we delegate the 
evaluation of binary and unary operations to $\HOLConst{eval\_bop}$ and $\HOLConst{eval\_uop}$. 
Similarly, we first type the argument expressions and then check the input and output 
types against the concrete operators using separate typing relations, $\HOLConst{boptype}$ 
and $\HOLConst{uoptype}$. This approach leads to two important properties: if the argument 
values are properly typed and the operator types match the argument types, then 
$\HOLConst{eval\_bop}$ and $\HOLConst{eval\_uop}$ will always output a value of the correct 
type or result in an exception. We refer to these properties as type soundness for $\HOLConst{eval\_bop}$ 
and $\HOLConst{eval\_uop}$.

\begin{prop}\label{prop:boptypesoundness}
    - bop soundness
\end{prop}

\emph{Proof:} $\HOLConst{boptype}$ is non-recursive. We prove by performing
cases analyses based on $\HOLConst{boptype}$ rules and each case follows
from Lemma~\ref{lem:canvaluetype}. \hfill \(\square\)

\begin{prop}\label{prop:uoptypesoundness}
    - uop soundness
\end{prop}

\emph{Proof:} Same as the above. \hfill \(\square\)

Proposition~\ref{prop:boptypesoundness} and Proposition~\ref{prop:uoptypesoundness} are 
required for the binary and unary operator cases in the type soundness proof. 
By the inductive hypothesis, we will have well-typed evaluated argument values, and we 
need to show that $\HOLConst{eval\_bop}$ or $\HOLConst{eval\_uop}$ either outputs 
a well-typed value or results in an exception.

There is also a lemma that allows us to update $\HOLFreeVar{G}$ and $\HOLFreeVar{E}$ with a typed
value and re-establish the $\HOLConst{envtype}$ property:

\begin{lem}\label{lem:envtype_lemma}
    - envtype_lemma
\end{lem}

\emph{Proof:} Since the typing rules for values (Definition~\ref{def:value_type}) are defined inductively, 
we will prove them by induction on Definition~\ref{def:value_type}. The base cases include 
integer, string, and boolean literals, which directly follow 
from the definition of $\HOLConst{envtype}$ (Definition~\ref{def:envtype}). The cases for 
pair and sum values derive directly from the inductive hypothesis. The 
closure value case does not rely on the inductive hypothesis; instead, it follows from 
the closure case in the lemma of canonical forms of types (Lemma~\ref{lem:canvaluetype}). \hfill \(\square\)

This lemma is useful in the function, application, and sum cases of the type 
soundness proof, where we have sub-expressions within the goal expression that 
are typed in an extended typing environment. We need to re-establish the $\HOLConst{envtype}$ 
property for both the extended typing environment and the dynamic environment so that we can 
apply the results from the corresponding inductive hypothesis.

\subsubsection{Restricted Function Closure}\label{subsubsec:resfunclos}
Since we evaluate a function expression into a restricted closure value (as discussed 
in Section~\ref{subsec:sfunclos}), we will need the following lemmas for the function 
case in the type soundness proof. 
Given that \HOLtm{typecheck G (Fn s e) (fnT t1 t2)}, Lemma~\ref{lem:sgeneration} ensures 
that \HOLtm{typecheck (G|+(s, t1)) e t2}. From the premise of the goal, we have 
\HOLtm{envtype G E}. However, to show that 
\HOLtm{value_type (Clos s e (DRESTRICT E (free_vars e) \\ s)) (fnT t1 t2)}, we need to show 
that there exists a typing environment $\HOLFreeVar{G'}$ such that 
\HOLtm{envtype G' (DRESTRICT E (free_vars e) \\ s)} holds (Definition~\ref{def:value_type}). 
Clearly, the original $\HOLFreeVar{G}$ 
does not qualify, as its domain may be larger than that of \HOLtm{DRESTRICT E (free_vars e) \\ s}. 
Thus, Corollary~\ref{cor:minimaltypeenv}, which we will prove shortly, provides us with a 
minimal typing environment $\HOLFreeVar{G'}$ 
in which $\HOLFreeVar{e}$ has type $\HOLFreeVar{t2}$ and for which 
\HOLtm{envtype G' (DRESTRICT E (free_vars e) \\ s)} holds, thereby proving the goal.


% If we adopt the restricted $\textsc{S-Fn}$ semantics (discussed in Section~\ref{subsubsec:dereclos}),
% we will need the following lemmas so we can type the closure value that contains a more restricted 
% dynamic environment \HOLtm{Clos s e (DRESTRICT E (free_vars e) \\ s)} 
% given that the expression of function body $\HOLFreeVar{e}$ is typed in an un-restricted
% extended typing environment $\HOLFreeVar{G}(+x,t)$. However, the following lemmas hold 
% regardless of whether we adopt a restricted function closure. They are simply 
% unnecessary for the type soundness proof when using an unrestricted function 
% closure.

The first lemma states that if an expression $\HOLFreeVar{e}$ is typed in an environment 
$\HOLFreeVar{G}$, then $\HOLFreeVar{G}$ contains type information for all free variables of $\HOLFreeVar{e}$.

\begin{lem}\label{lem:typecheck_env_fv}
    - typecheck_env_fv
\end{lem}

\emph{Proof:} By rule induction on Definition~\ref{def:typecheck}. \hfill \(\square\)

The second lemma states that if an expression $\HOLFreeVar{e}$ is typed in 
an environment $\HOLFreeVar{G1}$, then $\HOLFreeVar{e}$ retains the same type 
in a smaller typing environment $\HOLFreeVar{G2}$, provided that $\HOLFreeVar{G2}$ 
contains type information for all free variables in $\HOLFreeVar{e}$.

\begin{lem}\label{lem:typecheck_env_submap}
    - typecheck_env_submap
\end{lem}

\emph{Proof:} By rule induction on Definition~\ref{def:typecheck}. \hfill \(\square\)

The third lemma states that we can always type the expression $\HOLFreeVar{e}$ 
in a smaller typing environment, provided that the smaller typing environment 
still includes the bindings for the free variables of $\HOLFreeVar{e}$.

\begin{lem}\label{lem:typecheck_drestrict}
    - typecheck_drestrict
\end{lem}

\emph{Proof:} Follows directly from Lemma~\ref{lem:typecheck_env_fv} and Lemma~\ref{lem:typecheck_env_submap}. \hfill \(\square\)

Lemma~\ref{lem:typecheck_drestrict} and Lemma~\ref{lem:typecheck_env_fv} provide 
the existence of a minimal typing environment for an expression $\HOLFreeVar{e}$, 
containing exactly the bindings for all free variables of $\HOLFreeVar{e}$.

\begin{cor}\label{cor:minimaltypeenv}
    - minimal typing env
\end{cor}

\emph{Proof:} By Lemma~\ref{lem:typecheck_drestrict}, we know that if there exists some 
$\HOLFreeVar{G}$ such that \HOLtm{typecheck G e t}, then we have 
\HOLtm{typecheck (DRESTRICT G (free_vars e)) e t}. According to 
Lemma~\ref{lem:typecheck_env_fv}, $\HOLFreeVar{G}$ contains bindings for all 
free variables in $\HOLFreeVar{e}$; thus, \HOLtm{DRESTRICT G (free_vars e)} 
contains exactly the bindings for all free variables in $\HOLFreeVar{e}$, given Definition~\ref{def:derestrict}. 

For the reverse direction, suppose there exists a typing environment $\HOLFreeVar{G'}$ 
that contains fewer bindings than \HOLtm{DRESTRICT G (free_vars e)}, and we have 
\HOLtm{typecheck G' e t}. By Lemma~\ref{lem:typecheck_env_fv}, $\HOLFreeVar{G'}$ 
must contain bindings for all free variables in $\HOLFreeVar{e}$, leading to a contradiction. \hfill \(\square\)

%% TODO consider including remarks?

\subsection{Type Soundness}\label{subsec:envTypingSoundness}

We are now ready to prove the type soundness property for \richerlang{}. 

\begin{thm}\label{thm:stype_soundness}
    \begin{HOLmath}
        \HOLthm{envSem.type_soundness}
    \end{HOLmath}
\end{thm}

\emph{Proof:} We prove this by induction on the definition of $\HOLConst{eval\_exp}$. 
The case for $\HOLConst{Var}$ follows directly from Definition~\ref{def:envtype}. 
In the case of \HOLtm{Let s e1 e2}, by Lemma~\ref{lem:sgeneration}, we have 
\HOLtm{typecheck G e1 t0} and \HOLtm{ typecheck (G |+ (s,t0)) e2 t}, 
given that \HOLtm{typecheck G (Let s e1 e2) t}. Then, by the inductive hypothesis 
for $\HOLFreeVar{e1}$, we know that $\HOLFreeVar{e1}$ 
evaluates to some value $\HOLFreeVar{v}$ and we have \HOLtm{value_type v t0}. 
Lemma~\ref{lem:envtype_lemma} then provides us with \HOLtm{envtype (G |+ (s,t0)) (E |+ (s,v))}. 
This allows us to apply the results from the inductive hypothesis to $\HOLFreeVar{e2}$, 
thereby proving our goal. 

For all following cases, we assume that Lemma~\ref{lem:sgeneration} is applied 
first. 

For \HOLtm{Fn s e} case, given \HOLtm{envtype G E} and \HOLtm{typecheck (G |+ (s,t1)) e t2}, 
we need to show that \HOLtm{value_type (Clos s e (DRESTRICT E (free_vars e) \\ s)) (fnT t1 t2)}. 
According to the definitions of $\HOLConst{value\_type}$ (Definition~\ref{def:value_type}) 
and $\HOLConst{envtype}$ (Definition~\ref{def:envtype}), we must demonstrate the existence of 
a typing environment $\HOLFreeVar{G0}$ such that \HOLtm{typecheck (G0 |+ (s,t1)) e t2} 
and \HOLtm{envtype G0 (DRESTRICT E (free_vars e) \\ s)}. 

By Corollary~\ref{cor:minimaltypeenv}, we know there exists a minimal typing environment $\HOLFreeVar{G'}$ 
such that \HOLtm{typecheck (G' |+ (s,t1)) e t2}, and this environment contains bindings for all 
free variables of $\HOLFreeVar{e}$, excluding the binding for $\HOLFreeVar{s}$ if \HOLtm{s ∈ (free_vars e)}. 
Therefore, by the definition of $\HOLConst{DRESTRICT}$ (Definition~\ref{def:derestrict}) and 
Definition~\ref{def:envtype}, we have found such an environment $\HOLFreeVar{G0}$, which is $\HOLFreeVar{G'}$.

If we use an unrestricted function closure in Definition~\ref{def:sdynamicsrules} instead, 
we need to show \HOLtm{value_type (Clos s e E) (fnT t1 t2)}, which is straightforward
given Definition~\ref{def:value_type}.

For $\HOLConst{BinOp}$ and $\HOLConst{Uop}$ cases, results follow directly from
Proposition~\ref{prop:uoptypesoundness} and Proposition~\ref{prop:boptypesoundness},
as discussed in Section~\ref{subsec:envTypingProperties}.

For \HOLtm{If e e1 e2} case, the inductive hypothesis for the guard expression 
$\HOLFreeVar{e}$ tells us that $\HOLFreeVar{e}$ evaluates to a value $\HOLFreeVar{v}$, where 
\HOLtm{value_type v boolT}. By Lemma~\ref{lem:canvaluetype}, we know that $\HOLFreeVar{v}$ 
must be either \HOLtm{BoolV T} or \HOLtm{BoolV F}. Both the true and false branches are covered by 
the inductive hypotheses.

For \HOLtm{App e1 e2} case, the inductive hypotheses for $\HOLFreeVar{e1}$ and 
$\HOLFreeVar{e2}$ tell us that they evaluate to $\HOLFreeVar{v1}$ and $\HOLFreeVar{v2}$, 
respectively. We also know that \HOLtm{value_type v1 (fnT t1 t2)} and \HOLtm{value_type v2 t1}. 
By Lemma~\ref{lem:canvaluetype}, we conclude that $\HOLFreeVar{v1}$ is a function closure, 
represented as \HOLtm{Clos s e E}, which matches the expressions in our 
goal. Additionally, Lemma~\ref{lem:canvaluetype} provides us with \HOLtm{typecheck (G |+ (s,t1)) e t2}, 
where \HOLtm{envtype G E}. 
Applying Lemma~\ref{lem:envtype_lemma}, we obtain \HOLtm{envtype (G |+ (s,t1)) (E |+ (s,v2))}. 
This allows us to utilise the inductive hypothesis for $\HOLFreeVar{e}$, which solves the goal.

For \HOLtm{Case e s1 e1 s2 e2} case, the inductive hypothesis tells us 
that $\HOLFreeVar{e}$ evaluates to a value $\HOLFreeVar{v}$, where 
\HOLtm{value_type v (sumT t1 t2)}. By Lemma~\ref{lem:canvaluetype}, we know 
that $\HOLFreeVar{v}$ is either \HOLtm{SumLV v'} or \HOLtm{SumRV v'} for some 
value $\HOLFreeVar{v'}$. 

In both scenarios, we have either \HOLtm{value_type v' t1} or \HOLtm{value_type v' t2}. 
Consequently, by Lemma~\ref{lem:envtype_lemma}, we find either 
\HOLtm{envtype (G |+ (s1,t1)) (E |+ (s1,v'))} or \HOLtm{envtype (G |+ (s2,t2)) (E |+ (s2,v'))}. 
This enables us to apply the inductive hypothesis for $\HOLFreeVar{e1}$ or $\HOLFreeVar{e2}$, 
which solves the goal. \hfill \(\square\)