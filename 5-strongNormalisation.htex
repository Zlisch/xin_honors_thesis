\chapter{Strong Normalisation}\label{chap:strongNormalisation}
We find that the strong normalization property of \richerlang{} is essential 
for re-establishing the progress property in the enriched choreography. 
Without it, if local computation in one of the processes fails to terminate, 
the choreography will deadlock, waiting indefinitely for that process to complete.

%% TODO literature review section ref
The differences between our approach to proving strong normalisation and a more 
standard method involving simply typed lambda calculus with non-deterministic 
reductions, small-step semantics, and substitutions are discussed in Section~?. 
In brief, a straightforward induction over Definition~\ref{def:typecheck} fails 
in the case of \HOLtm{App e1 e2}, because the $\HOLFreeVar{e}$ in the 
function closure \HOLtm{Clos s e E} of $\HOLFreeVar{e1}$ can be arbitrarily large. 
Instead, we use induction over the types of values, which leads us to define 
\emph{strongly normalizing values}, as introduced in Definition~\ref{def:sn_v}.

\richerlang's evaluation function is deterministic by using a functional big-step semantics, so the strong normalisation 
proof for \richerlang\; is equivalent to the weak normalisation proof.

\section{Formalisation}\label{sec:defsn}
We now introduce the definitions of logical relations needed to state the Fundamental Lemma.

\subsubsection{Strongly Normalising Values}\label{subsubsec:snvalues}
In a standard simply typed lambda calculus, terms can be values, but 
in \richerlang, values are not part of the expression syntax. Instead, in the 
recursive cases of our evaluation function (Definition~\ref{def:sdynamicsrules}), 
the values of sub-expressions are evaluated first and then used to evaluate 
the current expression. Therefore, we define \HOLtm{sn_v t v} as an inductive 
notion of strongly normalising values, indicating that these values demonstrate 
strong normalization behaviour of specific types during evaluation.

\begin{definition}\label{def:sn_v}
    - sn_v
\end{definition}

Literal values are always strongly normalising. For a closure value \HOLtm{Clos s e E} 
of type \HOLtm{fnT t1 t2} to be strongly normalising, we require that if the expression 
$\HOLFreeVar{e}$ in \HOLtm{E|+(s,v)} is evaluated, given that the value $\HOLFreeVar{v}$ 
of type $\HOLFreeVar{t1}$ is strongly normalising, then the evaluation of $\HOLFreeVar{e}$ 
must always return a strongly normalising value of type $\HOLFreeVar{t2}$ or result in an 
exception. A pair value \HOLtm{PairV v1 v2} of type \HOLtm{pairT t1 t2} is strongly 
normalising if and only if both $\HOLFreeVar{v1}$ and $\HOLFreeVar{v2}$ are strongly 
normalising. A \HOLtm{SumLV v} value of type \HOLtm{sumT t1 t2} is strongly normalising if 
and only if $\HOLFreeVar{v}$ is strongly normalising according to type $\HOLFreeVar{t1}$. 
The condition for \HOLtm{sn_v (sumT t1 t2) (SumRV v)} is defined similarly.

\subsubsection{Environments}
Since we assign values to free variables by looking them up in an environment during 
expression evaluation, we introduce a constraint between the typing environment and 
the dynamic environment. This constraint requires the dynamic environment to store 
strongly normalising values that correspond to the variables and types specified by 
the typing environment.

\begin{definition}\label{def:envsn}
    - envsn
\end{definition}

\subsubsection{Evaluation of Expressions}
We define the evaluation of an expression $\HOLFreeVar{e}$ of type $\HOLFreeVar{t}$ 
under the environment $\HOLFreeVar{E}$ as strongly normalising if and only if, for 
some initial clock $\HOLFreeVar{c}$, the evaluation returns a strongly normalising 
value or an exception.

\begin{definition}\label{def:sn_exec}
  \begin{HOLmath}
    \HOLthm[def]{typeSN.sn_exec_def}
  \end{HOLmath}
\end{definition}

We define the evaluation of an expression $\HOLFreeVar{e}$, typed under the typing 
environment $\HOLFreeVar{G}$ with type $\HOLFreeVar{t}$, as strongly normalising if 
and only if the evaluation of $\HOLFreeVar{e}$ is strongly normalising under any dynamic 
environment $\HOLFreeVar{E}$ that satisfies \HOLtm{envsn (DRESTRICT G (free_vars e)) E}.

\begin{definition}\label{def:sn_e}
    - sn_e
\end{definition}

We use \HOLtm{DRESTRICT G (free_vars e)} instead of $\HOLFreeVar{G}$ to accommodate 
the restricted environment used in closures, as defined in Definition~\ref{def:sdynamicsrules}. 
This adjustment is necessary to re-establish Proposition~\ref{prop:transsubmap}. 
Further discussion on Proposition~\ref{prop:transsubmap} and the modifications made 
to restore it can be found in Section~\ref{subsec:largerState}.

If we only require \HOLtm{envsn G E} for any $\HOLFreeVar{E}$ in the definition 
of $\HOLConst{sn_e}$, the inductive hypothesis for the function expression \HOLtm{Fn s e} 
becomes inapplicable. This prevents us from proving that the evaluated closure value is 
strongly normalising with respect to the type of the function expression, specifically 
\HOLtm{sn_v (fnT t t') (Clos s e (DRESTRICT E (free_vars e) \\ s))}.
This is because, according to Definition~\ref{def:sn_v}, the body $\HOLFreeVar{e}$ 
in the function closure must be evaluated in the restricted dynamic environment 
\HOLtm{DRESTRICT E (free_vars e) \\ s} captured by 
the closure. Therefore, we need to instantiate the dynamic environment in the inductive 
hypothesis for $\HOLFreeVar{e}$ as \HOLtm{DRESTRICT E (free_vars e) \\ s}. However, 
this necessitates first proving \HOLtm{envsn (G|+(s,t)) (DRESTRICT E (free_vars e) \\ s)} 
in order to apply the results of the inductive hypothesis for $\HOLFreeVar{e}$. 
Unfortunately, \HOLtm{envsn (G|+(s,t)) (DRESTRICT E (free_vars e) \\ s)} cannot be deduced 
from \HOLtm{envsn (G|+(s,t)) E}, which is the premise for the current goal. This is 
because $\HOLFreeVar{G}$ may contain arbitrary variables that are not included in \HOLtm{DRESTRICT E (free_vars e) \\ s}.

Thus, we modify the definition of $\HOLConst{sn_e}$ to use a restricted typing 
environment that aligns with the restricted dynamic environment in a function 
closure. We require this restricted typing environment to include types for at 
most all free variables of the expression being evaluated. After introducing this 
restriction, the condition for the inductive hypothesis of $\HOLFreeVar{e}$ becomes 
\HOLtm{envsn (DRESTRICT G (free_vars e) |+ (s,t)) (DRESTRICT E (free_vars e) |+ (s,v))}, 
which can be deduced from \HOLtm{envsn (DRESTRICT G (free_vars e DELETE s)) E}, 
the new premise of the current goal following the restriction of the typing environment.

\section{Auxillary Lemmas}\label{sec:snauxlemmas}
In this section, we present several lemmas related to the definitions introduced in 
Section~\ref{sec:defsn}. These lemmas will be utilised in the proof of the Fundamental Lemma.

Similar to the lemma of canonical forms for typed values (Lemma~\ref{lem:canvaluetype}), 
we have a lemma of canonical forms for strongly normalising values. This lemma 
allows us to express a value $\HOLFreeVar{v}$ that satisfies \HOLtm{sn_v t v} for 
some $\HOLFreeVar{t}$ in a concrete syntax. This is particularly useful when proving 
Lemma~\ref{lem:bop_sn_lemma} and~\ref{lem:uop_sn_lemma}. Additionally, Lemma~\ref{lem:canvaluesn} 
is used to prove the $\HOLConst{If}$, $\HOLConst{App}$, and $\HOLConst{Case}$ cases 
in the Fundamental Lemma proof, as it enables us to represent the boolean guard value, function 
closure value, and sum value in their concrete syntax rather than simply referring to them as $\HOLFreeVar{v}$.

\begin{lem}\label{lem:canvaluesn}
    - sn_v_*
\end{lem}

\emph{Proof:} Immediately follows from Definition~\ref{def:sn_v}. \hfill \(\square\)

The following lemmas regarding \HOLtm{envsn G E} prove to be quite useful 
in the proof of the Fundamental Lemma, particularly when we need to pair 
$\HOLFreeVar{G}$ with a larger or smaller $\HOLFreeVar{E}$ while maintaining 
the \HOLConst{envsn} relation.

\begin{lem}\label{lem:envsnlemmas}
    envsn lemmas
    \begin{enumerate}
        \item envsn_g_submap \label{lem:envsnlemmas1}
        \item envsn_update \label{lem:envsnlemmas2}
        \item envsn_e_submap2 \label{lem:envsnlemmas3}
        \item envsn_e_submap \label{lem:envsnlemmas4}
    \end{enumerate}
\end{lem}

\emph{Proof:} Follows directly from Definition~\ref{def:envsn}. \hfill \(\square\)

Property~\ref{lem:envsnlemmas1} enables us to establish \HOLtm{envsn G' E} for some 
$\HOLFreeVar{G'}$ that is 
smaller than $\HOLFreeVar{G}$. This is particularly useful when we have 
\HOLtm{envsn (DRESTRICT G (free_vars e)) E} and wish to deduce 
\HOLtm{envsn (DRESTRICT G (free_vars e1)) E} and \HOLtm{envsn (DRESTRICT G (free_vars e2)) E} 
in order to apply the inductive hypotheses for the sub-expressions $\HOLFreeVar{e1}$ 
and $\HOLFreeVar{e2}$ of $\HOLFreeVar{e}$. This is because the free variables of an 
expression are typically defined as the union of the free variables of each of its 
sub-expressions. Property~\ref{lem:envsnlemmas2} is used in the $\HOLConst{Let}$ and $\HOLConst{Sum}$ cases 
of the Fundamental Lemma proof.

Property~\ref{lem:envsnlemmas3} allows us to establish the $\HOLConst{envsn}$ property between 
$\HOLFreeVar{G}$ and a larger $\HOLFreeVar{E}$. This lemma is used to re-stablish the $\HOLConst{envsn}$
property required by the inductive hypotheses when the variable $\HOLFreeVar{x}$, bound 
by $\HOLConst{Fn}$, $\HOLConst{Let}$, or $\HOLConst{Case}$, is not utilised in a later expression 
$\HOLFreeVar{e}$. As a result, the variable $\HOLFreeVar{x}$ is not included in the typing 
environment for $\HOLFreeVar{e}$, as $\HOLFreeVar{x}$ is not a free variable of $\HOLFreeVar{e}$. However, 
our dynamic rules do not account for this information and still evaluate $\HOLFreeVar{e}$ 
with the previous environment, updated with the value of $\HOLFreeVar{x}$. In this case, 
Property~\ref{lem:envsnlemmas1} is not directly applicable since we do not update the typing 
environment. Instead, with 
Property~\ref{lem:envsnlemmas3}, we can extend the dynamic environment to include additional 
information about the values 
of unused variables.

Property~\ref{lem:envsnlemmas4} is used to address the restricted function 
closure in the $\HOLConst{Fn}$
case of the Fundamental Lemma proof. The premise of our current goal provides us with 
\HOLtm{envsn (DRESTRICT G (free_vars e DELETE s)) E}, but we need to establish 
the $\HOLConst{envsn}$ property for the restricted environment in the function closure 
\HOLtm{Clos s e (DRESTRICT E (free_vars e) \\ s)}. 
So we can apply the inductive hypothesis for the function body expression $\HOLFreeVar{e}$ 
stored in the closure. Property~\ref{lem:envsnlemmas4} enables us to reduce the dynamic 
environment, provided that the modified environment 
still encompasses all variables included in the typing environment.

Finally, we require the last two lemmas to address the $\HOLConst{BinOp}$ and 
$\HOLConst{Uop}$ cases. In the \HOLtm{BinOp bop e1 e2} case, if the inductive 
hypotheses indicate that $\HOLFreeVar{e1}$ and $\HOLFreeVar{e2}$ both evaluate 
to values $\HOLFreeVar{v1}$ and $\HOLFreeVar{v2}$, respectively, we need Lemma~\ref{lem:bop_sn_lemma} 
to ensure that, given \HOLtm{sn_v t1 v1} and \HOLtm{sn_v t2 v2}, the expression 
\HOLtm{eval_bop bop v1 v2} always returns either a value or an exception. The same 
reasoning applies to the $\HOLConst{Uop}$ case.

\begin{lem}\label{lem:bop_sn_lemma}
    - bop_sn
\end{lem}

\emph{Proof:} $\HOLConst{boptype}$ is non-recursive. We prove by performing
cases analyses based on $\HOLConst{boptype}$ rules and each case follows
from Lemma~\ref{lem:canvaluesn}. \hfill \(\square\)

\begin{lem}\label{lem:uop_sn_lemma}
    - uop_sn
\end{lem}

\emph{Proof:} Same as the above. \hfill \(\square\)

\section{The Fundamental Lemma}
Using the definitions from Section~\ref{sec:defsn}, we state the Fundamental Lemma as:

\begin{lem}\label{lem:sn_lemma}
    - sn_lemma
\end{lem}

\subsection{Strategy}\label{subsec:strategysn}
% We prove via rule induction over Definition~\ref{def:typecheck}. The main strategy in each case
% is to first deduce the $\HOLConst{envsn}$ property required by the inductive hypotheses
% from the premise of the current goal. Then we have the sub-expressions of current expression 
% either evaluate to a value or an exception by the corresponding inductive hypotheses.
% If some sub-expression evaluates to an exception, the monadic binds used in Definition~\ref{def:sdynamicsrules}
% will ensure the evaluation in the goal return the exception. We only need to find a clock value under which
% the first sub-expression evaluating to an exception and all the sub-expressions evaluating to 
% values before it still evaluate to the same exception and the values. By Lemma~\ref{lem:clock_value_increment} and~\ref{lem:clock_exn_increment},
% we can always use the summation of clock values used to evaluate those sub-expressions as the clock value used in
% evaluations in the goal statements to evaluate those sub-expressions to the same results.

We prove this using rule induction over Definition~\ref{def:typecheck}. The primary 
strategy in each case is to first derive the $\HOLConst{envsn}$ property 
required by the inductive hypotheses from the premise of the current goal. Subsequently, 
we consider the sub-expressions of the current expression, which will either evaluate to 
a value or an exception based on the corresponding inductive hypotheses. If any sub-expression 
evaluates to an exception, the monadic binds employed in Definition~\ref{def:sdynamicsrules} 
will ensure that the evaluation in the goal returns that exception.

We need to identify a clock value under which the first sub-expression that evaluates 
to an exception, along with all preceding sub-expressions that evaluate to values, continues 
to produce the same results. By applying Lemma~\ref{lem:clock_value_increment} and~\ref{lem:clock_exn_increment}, 
we can consistently use the summation of the clock values employed to evaluate these 
sub-expressions as the clock value for the evaluations in the goal statements, ensuring 
that they yield the same outcomes.

If no sub-expression evaluates to an exception, we either have an inductive hypothesis 
for the evaluation of some sub-expression that utilises the evaluated values, or we have 
an external $\HOLConst{eval\_bop}$ or $\HOLConst{eval\_uop}$ that makes use of those values. 
In the first case, we need to establish the $\HOLConst{envsn}$ property required by the 
inductive hypothesis, which typically relies on Lemma~\ref{lem:envsnlemmas}. In the second 
case, we must apply Lemma~\ref{lem:bop_sn_lemma} and ~\ref{lem:uop_sn_lemma}.

The proof strategy itself is fairly straightforward; however, the evaluation of many expressions 
requires evaluating sub-expressions first (as outlined in Definition~\ref{def:sdynamicsrules}). 
This results in numerous similar cases, each requiring slightly different tactics, which 
contributes to the length of the HOL proof. For instance, the expression \HOLtm{BinOp bop e1 e2} 
requires that we first evaluate $\HOLFreeVar{e1}$ and $\HOLFreeVar{e2}$ before calling $\HOLConst{eval\_bop}$ 
with the evaluated values. This leads to four distinct cases, as both $\HOLFreeVar{e1}$ and $\HOLFreeVar{e2}$ 
can evaluate to either a value or an exception.

Additionally, as discussed in Lemma~\ref{lem:envsnlemmas} (~\ref{lem:envsnlemmas3}), 
if the bound variable $\HOLFreeVar{x}$ is not used in a sub-expression $\HOLFreeVar{e}$, 
the $\HOLConst{envsn}$ statement in the inductive hypothesis for $\HOLFreeVar{e}$ will be 
\HOLtm{envsn (DRESTRICT G (free_vars e)) (E |+ (x,v))}. In contrast, if $\HOLFreeVar{x}$ is 
used in $\HOLFreeVar{e}$, the statement would be \HOLtm{envsn (DRESTRICT G (free_vars e) |+ (x,t)) (E |+ (x,v))}. 
These two cases require slightly different proofs for reasons discussed in Section~\ref{sec:snauxlemmas}, 
and this added layer of distinction increases 
the number of generated cases, particularly for the $\HOLConst{Fn}$, $\HOLConst{Let}$, and $\HOLConst{Case}$ 
scenarios.

\subsection{Proof}\label{subsec:snproof}
\emph{Base cases.} Evaluation for literals always return values and those values are related to the 
types of literal expressions by $\HOLConst{sn\_v}$. For variable expressions, the goal follows from 
Definition~\ref{def:envsn}.

\emph{Function.} Consider a function expression \HOLtm{Fn s e} of type \HOLtm{fnT t1 t2}. 
Since we are using induction over type checking relation (Definition~\ref{def:typecheck}), we have one inductive 
hypothesis for evaluating $\HOLFreeVar{e}$. According to Definition~\ref{def:sdynamicsrules}, 
a function expression always evaluates to a closure. We then need to 
show this closure is related to \HOLtm{fnT t1 t2} by $\HOLConst{sn_v}$. 
According to Definition~\ref{def:sn_v}, we need to demonstrate that for any 
$\HOLFreeVar{v}$ such that \HOLtm{sn_v t1 v}, 
evaluating $\HOLFreeVar{e}$ in the closure's environment extended with binding 
$\HOLFreeVar{s}$ to $\HOLFreeVar{v}$ either returns a value or an exception. 
This aligns with the result of the inductive hypothesis for $\HOLFreeVar{e}$. 
From the discussion in Section~\ref{sec:defsn}, we know that the $\HOLConst{envsn}$ 
property required to use the inductive 
hypothesis for $\HOLFreeVar{e}$ can be deduced from the premise of the current goal.

\emph{If expression.} Consider an if expression \HOLtm{If bg e1 e2}. The $\HOLConst{If}$ case follows the 
strategy outlined in Section~\ref{subsec:strategysn}. According to Definition~\ref{def:sn_e}, 
the condition for \HOLtm{sn_exec t E (If bg e1 e2)} requires \HOLtm{envsn (DRESTRICT G (free_vars (If bg e1 e2))) E}. 
Since the free variables of \HOLtm{If bg e1 e2} are the union of those in $\HOLFreeVar{bg}$, 
$\HOLFreeVar{e1}$, and $\HOLFreeVar{e2}$, Lemma~\ref{lem:envsnlemmas} (~\ref{lem:envsnlemmas1}) 
allows us to establish \HOLtm{envsn (DRESTRICT G (free_vars bg)) E}, \HOLtm{envsn (DRESTRICT G (free_vars e1)) E}, 
and \HOLtm{envsn (DRESTRICT G (free_vars e2)) E}. With these, we can apply the inductive 
hypotheses for $\HOLFreeVar{bg}$, $\HOLFreeVar{e1}$, and $\HOLFreeVar{e2}$.

Since each of them can evaluate to either a value or an exception, this generates 
$2^3$ cases. If $\HOLFreeVar{bg}$ evaluates to an exception, then \HOLtm{If bg e1 e2} 
will evaluate to an exception regardless of the outcomes of $\HOLFreeVar{e1}$ and 
$\HOLFreeVar{e2}$. If $\HOLFreeVar{bg}$ evaluates to a value $\HOLFreeVar{v}$, we apply 
the canonical form lemma (Lemma~\ref{lem:canvaluesn}) to express $\HOLFreeVar{v}$ as 
\HOLtm{BoolV b}. Depending on the value of $\HOLFreeVar{b}$ 
and the evaluation results of $\HOLFreeVar{e1}$ and $\HOLFreeVar{e2}$ (which could be either 
a value or an exception as given by the corresponding inductive hypothesis), we use Lemma~\ref{lem:clock_value_increment} and~\ref{lem:clock_exn_increment}, 
instantiated with the clock value $c_{bg} + c_1 + c_2$, to prove the goal.

\emph{Binary operation.} Consider a binary operation \HOLtm{BinOp bop e1 e2}. The $\HOLConst{BinOp}$ 
case is similar to the $\HOLConst{If}$ case and follows the strategy outlined 
in Section~\ref{subsec:strategysn}. From the premise of the current goal, we 
can deduce the necessary $\HOLConst{envsn}$ 
conditions to use the inductive hypotheses for $\HOLFreeVar{e1}$ and $\HOLFreeVar{e2}$ by
applying Lemma~\ref{lem:envsnlemmas} (~\ref{lem:envsnlemmas1}). Since both $\HOLFreeVar{e1}$ 
and $\HOLFreeVar{e2}$ can evaluate to either a 
value or an exception, this generates $2^2$ cases.

If either $\HOLFreeVar{e1}$ or $\HOLFreeVar{e2}$ evaluates to an exception, we use 
Lemma~\ref{lem:clock_value_increment} and~\ref{lem:clock_exn_increment} with the clock 
value $c_1 + c_2$ to prove the goal. If both $\HOLFreeVar{e1}$ and 
$\HOLFreeVar{e2}$ evaluate to values $\HOLFreeVar{v1}$ and $\HOLFreeVar{v2}$ respectively, 
the inductive hypotheses provide \HOLtm{sn_v t1 v1} and \HOLtm{sn_v t2 v2}. We then 
instantiate Lemma~\ref{lem:clock_value_increment} with a clock value of $c_1 + c_2$ 
so that $\HOLFreeVar{e1}$ and $\HOLFreeVar{e2}$ 
are evaluated with the same clock value, reaching the same results $\HOLFreeVar{v1}$ 
and $\HOLFreeVar{v2}$. Finally, Lemma~\ref{lem:bop_sn_lemma} guarantees that \HOLtm{eval_bop v1 v2} 
will return either a value or an exception, completing the proof.

\emph{Unary operation.} Same as the binary operation case.

\emph{Let expression.} Consider a Let expression \HOLtm{Let s e1 e2}. Similar to the previous cases, we use 
Lemma~\ref{lem:envsnlemmas} (~\ref{lem:envsnlemmas1}) to deduce the $\HOLConst{envsn}$ conditions 
required for applying the inductive hypothesis of 
$\HOLFreeVar{e1}$. If $\HOLFreeVar{e1}$ evaluates to an exception, the proof is complete. If $\HOLFreeVar{e1}$ 
evaluates to a value $\HOLFreeVar{v}$, we need to show that evaluating $\HOLFreeVar{e2}$ within \HOLtm{E|+(s,v)} 
will either return a value or an exception. This outcome aligns with the inductive hypothesis for $\HOLFreeVar{e2}$.

By applying Lemma~\ref{lem:envsnlemmas} (~\ref{lem:envsnlemmas2}), we establish 
\HOLtm{envsn (G|+(s,t1)) (E|+(s,v))}. This allows us to use the inductive hypothesis 
for $\HOLFreeVar{e2}$, confirming that evaluating $\HOLFreeVar{e2}$ within \HOLtm{E|+(s,v)} will result 
in either a value or an exception. Finally, by instantiating Lemma~\ref{lem:clock_value_increment} and~\ref{lem:clock_exn_increment} 
with a clock value of $c_1 + c_2$, we complete the proof.

As discussed in Section~\ref{sec:snauxlemmas} regarding Lemma~\ref{lem:envsnlemmas} (~\ref{lem:envsnlemmas3}), 
if $\HOLFreeVar{s}$ is not used in $\HOLFreeVar{e2}$, meaning $\HOLFreeVar{s}$ 
is not a free variable in $\HOLFreeVar{e2}$, the inductive hypothesis for $\HOLFreeVar{e2}$ 
requires \HOLtm{envsn G (E |+ (s,v))}. Lemma~\ref{lem:envsnlemmas} (~\ref{lem:envsnlemmas3}) allows 
us to deduce \HOLtm{envsn G (E |+ (s,v))} in this situation.

\emph{Application.} Application case follows the strategy stated in Section~\ref{subsec:strategysn} and 
is similar to the $\HOLConst{If}$ case.

\emph{Case expression.} Consider a case expression \HOLtm{Case e s1 e1 s2 e2}. The proof follows the 
strategy outlined in Section~\ref{subsec:strategysn}, where Lemma~\ref{lem:envsnlemmas} (~\ref{lem:envsnlemmas1}) 
is used to apply the inductive hypothesis for $\HOLFreeVar{e}$. However, 
additional case analyses are needed to determine whether $\HOLFreeVar{s1}$ is a 
free variable in $\HOLFreeVar{e1}$ and whether $\HOLFreeVar{s2}$ is a free variable 
in $\HOLFreeVar{e2}$. This additional analysis is similar to what is required in 
the $\HOLConst{Let}$ case, where either Lemma~\ref{lem:envsnlemmas} (~\ref{lem:envsnlemmas3}) 
or Lemma~\ref{lem:envsnlemmas} (~\ref{lem:envsnlemmas2}) is used to apply the inductive hypothesis 
for each situation. \hfill \(\square\)

\subsection{Strong Normalisation}\label{subsec:snresult}
We now state the strong normalisation property for \richerlang{}:

\begin{cor}\label{cor:snthm}
    \begin{HOLmath}
        \HOLthm{typeSN.richerLang_sn}
    \end{HOLmath}
\end{cor}

\emph{Proof:} Follows from Lemma~\ref{lem:sn_lemma} \hfill \(\square\)

Corollary~\ref{cor:snthm} says that if a closed expression of \richerlang\;is well-typed,
then it either evaluates to a value or to an exception.

This result is nice on its own; however, Corollary~\ref{cor:snthm} 
only establishes the existence of such an environment $\HOLFreeVar{E}$. 
As a result, this finding is not directly applicable in the progress and 
type preservation proof for the enriched choreography. Instead, we aim to 
show that the evaluation of a typed expression terminates 
in the localised choreography environment. Theorem~\ref{thm:richerLang_localise_sn} 
in Section~\ref{subsubsec:snlocalisedEnv} provides this crucial result.