\chapter{Introduction}

Distributed systems consist of multiple endpoints that communicate by 
exchanging messages, operating with asynchrony and parallelism as these 
messages are sent and received between the various endpoints. But programming 
distributed system is notoriously error-prone as programmer has to implement 
the communication protocol by developing individual endpoint programs. Mismatched 
message sending and receiving can lead to errors such as \emph{deadlock}, where 
the system is waiting forever for a message.

\emph{Choreography} arises as a programming diagram to address this issue by providing a 
concrete global description of how the messages are exchanged between endpoints
in a distributed system. A choreography program is written in a similar style to the 
"Alice and Bob" notation by \cite{needham_using_1978}: 
\begin{center}
    \begin{tabular}{rl}
      \texttt{1.} & \texttt{Alice} $\to$ \texttt{Bob} $: key$ \\
      \texttt{2.} & \texttt{Bob} $\to$ \texttt{Alice} $: message$ \\
    \end{tabular}
\end{center}
Thus message mismatches are disallowed from the choreographic 
perspective. A property we refer to as \emph{deadlock free by design}. 
The global choreography is then projected into process models for each 
endpoint via EndPoint Projection (EPP), with properties such as 
deadlock free by design preserved \citep{hallal_global_2018}.

While most choreography languages focus on the message exchange behaviours, 
few pay attention to the local computation happening in the 
individual endpoint. It is shown by \cite{hirsch_pirouette_2022} that as 
long as the local language exhibits type preservation and 
progress, the choreography inherits these properties as well. Thus, when 
analyzing message exchange behaviors in choreography---such as multiparty 
sessions, asynchrony, and parallelism---one can safely assume good behaviours 
of local computation \citep{montesi_compositional_2013, cruz2017core, carbone_deadlock-freedom-by-design_2013}.

But when it comes to writing the choreography program that implements concrete system 
behaviours, if local computation is ever required by the system, one must describe 
the inputs and outputs of local computations. Current work either delegate this part to 
an assumed well-behaved external implementation, for example, Kalas~\cite{pohjola_kalas_2022} and Pirouette~\cite{hirsch_pirouette_2022},
or provide a basic framework where only Church numerals are considered, as in Core Choreography (CC)~\cite{cruz2017core}.
This makes writing choreography program with local computation implementation  
an unpleasant experience. For instance, a choreography program in Kalas, where the client 
computes modulo locally using input from the server and then sends the result back, will look like:

\begin{example}[Local computation --- Modulo]\label{ex:oldmod}\rule{3mm}{0mm}
  \begin{center}
    \begin{tabular}{rl|l}
      \multicolumn{2}{c|}{\cellcolor{vlightgray}\textnormal{Kalas}} & \comptitle{}{\textnormal{External computation}} \\
      \texttt{1.} & $\commprefix{\mathtt{server}}{var}{\mathtt{client}}{\mathit{x}}{}$; & $\textrm{\textbf{fun}}\;mod\;\mathit{x}\;=$\\
      \texttt{2.} & $\letin{\mathit{v}@\mathtt{client} = \mathtt{mod}(\mathit{x})}{}$ & $\quad\HOLKeyword{case}\;\ensuremath{\HOLConst{Option.map}\;(\HOLKeyword{fn}\;\HOLBoundVar{s}\;\HOLTokenImp{}\;\HOLConst{valOf}\;(\HOLConst{Int.fromString}\;\HOLBoundVar{s}))\;(\HOLConst{hd}\;\HOLFreeVar{x})}\;\HOLKeyword{of}$\\
      \texttt{3.} & $\commprefix{\mathtt{client}}{v}{\mathtt{server}}{\mathit{result}}{}$; & $\quad\;\;\HOLConst{None}\;\HOLTokenImp{}\;\HOLConst{None}$ \\
      & & $\quad\HOLTokenBar{}\;\HOLConst{Some}\;\HOLBoundVar{n}\;\HOLTokenImp{}\;\HOLConst{Some}\;[\HOLConst{Int.toString}\;(\HOLBoundVar{n}\;\HOLConst{MOD}\;\HOLFreeVar{y})]$ \\
    \end{tabular}
  \end{center}
\end{example}

In Kalas, processes communicate exclusively via strings. Therefore, in the external 
implementation of $\mathtt{mod}(\mathit{x})$, the string value of $\mathit{x}$ must 
first be converted to a number. Then client computes the modulo on the converted input.
Afterward, the result is converted back to a string before updating the client process 
variable $\mathit{v}$. We can easily see from this example that how data type conversions 
between choreography and external language lead to cumbersome code.

Thus this thesis extends Kalas, a verified choreography language with machine-checked 
end-to-end compilation, by introducing \richerlang, a simple language of expressions
over types such as integers, strings and booleans. Using the extended Kalas, 
local computations can be handled gracefully within a few lines of codes. The previous 
choreography where client computes the modulo of input integer can be written as in 
Example~\ref{ex:modenriched}. 

By providing a concrete local language syntax and semantics,
we are able to formally anlayse the message exchange behaviours of choreography 
in terms of progress and type preservation when local computations are considered.
We show that type soundness and strong normalisation properties of \richerlang\;
lead to progress for the enriched Kalas. Our semantics and typing system also
allow us to show type preservation for non-recursive and synchronous transitions in
the enriched Kalas.

\begin{example}[Local computation with \richerlang\;--- Modulo]\label{ex:modenriched}\rule{3mm}{0mm}
\begin{center}
  \begin{tabular}{rl}
    \texttt{1.} & $\commprefix{\mathtt{server}}{var}{\mathtt{client}}{\mathit{x}}{}$; \\
    \texttt{2.} & $\letin{\mathit{v}@\mathtt{client} = \HOLConst{StrOf}\;((\HOLConst{NumOf}\;(\HOLConst{Var}\;\HOLFreeVar{x}))\;\HOLConst{Mod}\;(\HOLConst{Var}\;\HOLFreeVar{y}))}{}$ \\
    \texttt{3.} & $\commprefix{\mathtt{client}}{v}{\mathtt{server}}{\mathit{result}}{}$; \\
  \end{tabular}
\end{center}
\end{example}

To summarise, this thesis provides three main contributions. 
\begin{itemize}
  \item The first contribution is \richerlang, a simply typed lambda calculus with function closure.
  According to the approach taken by \cite{owens2016functional}, we use a functional big-step semantics with
  clocks to ensure the evaluation function for \richerlang'\; expressions is total. Our evaluation 
  strategy is call-by-value. We also provide a typing system and give type soundness proof for 
  the proposed semantics and typing rules. \richerlang\; is implemented using the higher-order logic
  proof assistant HOL4 \citep{slind2008brief} and all the proofs are conducted within HOL4.
 
  \item The second contribution is the strong normalization proof for \richerlang. We follow the 
  standard practice for proving strong normalization in simply typed lambda calculus, 
  with a specific case for function closure in the definition of the strong normalization relation.

  \item The third contribution is Kalas enriched with \richerlang. Besides common data types such as 
  integer, string, and boolean, we also add function, pair, and sum types to the local computation in 
  Kalas. Common operators for our data types are included, such as addition, modulo, and negation.
  Integer-string convertor is implemented as well for the integration with Kalas. Last but not least, 
  we prove the enriched Kalas enjoys progress. We also show type preservation holds for non-recursive, 
  synchronous transitions in the enriched Kalas.
\end{itemize}

% - Thesis Structure
