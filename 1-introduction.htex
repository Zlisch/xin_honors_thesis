\chapter{Introduction}
Distributed systems consist of multiple endpoints that communicate by exchanging 
messages, operating asynchronously and in parallel as these messages are sent 
and received among the various endpoints. However, programming distributed systems 
is notoriously error-prone because programmers must implement the communication 
protocol by developing individual endpoint programs. Mismatched message sending 
and receiving can lead to errors such as \emph{deadlock}, where the system indefinitely 
waits for a message.

\emph{Choreographic programming} arises as a formalisaton to address this issue by providing a 
concrete global description of how the messages are exchanged between endpoints
in a distributed system. A choreography program is written in a similar style to the 
"Alice and Bob" notation by \cite{needham_using_1978}: 
\begin{center}
    \begin{tabular}{rl}
      \texttt{1.} & \texttt{Alice} $\to$ \texttt{Bob} $: key$ \\
      \texttt{2.} & \texttt{Bob} $\to$ \texttt{Alice} $: message$ \\
    \end{tabular}
\end{center}
Thus message mismatches are disallowed from the choreographic 
perspective. This property is known as \emph{deadlock-free-by-design}. 
The global choreography can then be projected into process models for each 
endpoint via EndPoint Projection (EPP), with properties such as 
deadlock free by design preserved \citep{hallal_global_2018}.

When analysing message exchange behaviors in choreography, such as multiparty sessions, 
asynchrony, and parallelism, it is reasonable to assume good behaviors in local 
computation \citep{montesi_compositional_2013, cruz2017core, carbone_deadlock-freedom-by-design_2013}. 
Consequently, most choreography languages focus primarily on message exchange behaviours, 
with few paying attention to the local computation occurring in individual endpoints. 
Although \cite{hirsch_pirouette_2022} demonstrates that for their assumed local language, 
as long as it exhibits type preservation and progress, the choreography inherits these 
properties, this result may not hold true for all local languages.

Additionally, when it comes to writing the choreography program that implements concrete system 
behaviours, if local computation is ever required by the system, one must describe 
the inputs and outputs of local computations. Current work either delegate this part to 
an assumed well-behaved external implementation, for example, Kalas~\cite{pohjola_kalas_2022} and Pirouette~\cite{hirsch_pirouette_2022},
or provide a basic framework where only Church numerals are considered, as in Core Choreography (CC)~\cite{cruz2017core}.
This makes writing choreography program with local computation implementation  
an unpleasant experience. For instance, a choreography program in Kalas, where the client 
computes modulo locally using input from the server and then sends the result back, will look like:

\begin{example}[Local computation --- Modulo]\label{ex:oldmod}\rule{3mm}{0mm}
  \begin{center}
    \begin{tabular}{rl|l}
      \multicolumn{2}{c|}{\cellcolor{vlightgray}\textnormal{Kalas}} & \comptitle{}{\textnormal{External computation}} \\
      \texttt{1.} & $\commprefix{\mathtt{server}}{var}{\mathtt{client}}{\mathit{x}}{}$; & $\textrm{\textbf{fun}}\;mod\;\mathit{x}\;=$\\
      \texttt{2.} & $\letin{\mathit{v}@\mathtt{client} = \mathtt{mod}(\mathit{x})}{}$ & $\quad\HOLKeyword{case}\;\ensuremath{\HOLConst{Option.map}\;(\HOLKeyword{fn}\;\HOLBoundVar{s}\;\HOLTokenImp{}\;\HOLConst{valOf}\;(\HOLConst{Int.fromString}\;\HOLBoundVar{s}))\;(\HOLConst{hd}\;\HOLFreeVar{x})}\;\HOLKeyword{of}$\\
      \texttt{3.} & $\commprefix{\mathtt{client}}{v}{\mathtt{server}}{\mathit{result}}{}$; & $\quad\;\;\HOLConst{None}\;\HOLTokenImp{}\;\HOLConst{None}$ \\
      & & $\quad\HOLTokenBar{}\;\HOLConst{Some}\;\HOLBoundVar{n}\;\HOLTokenImp{}\;\HOLConst{Some}\;[\HOLConst{Int.toString}\;(\HOLBoundVar{n}\;\HOLConst{MOD}\;\HOLFreeVar{y})]$ \\
    \end{tabular}
  \end{center}
\end{example}

In Kalas, processes communicate exclusively via strings. Therefore, in the external 
implementation of $\mathtt{mod}(\mathit{x})$, the string value of $\mathit{x}$ must 
first be converted to a number. Then client computes the modulo on the converted input.
Afterward, the result is converted back to a string before updating the client process 
variable $\mathit{v}$. We can easily see from this example that how data type conversions 
between choreography and external language lead to cumbersome code.

Thus this thesis extends Kalas, a verified choreography language with machine-checked 
end-to-end compilation, by introducing \richerlang, a simple language of expressions
over types such as integers, strings and booleans. Using the extended Kalas, 
local computations can be handled gracefully within a few lines of code. The previous 
choreography where client computes the modulo of input integer can be written as in 
Example~\ref{ex:modenriched}. 

By providing a concrete local language syntax and semantics,
we are able to formally anlayse the message exchange behaviours of choreography 
in terms of progress and type preservation when local computations are considered.
We show that type soundness and strong normalisation properties of \richerlang\;
lead to progress for the enriched Kalas. Our semantics and typing system also
allow us to show type preservation for non-recursive and synchronous transitions in
the enriched Kalas.

\begin{example}[Local computation with \richerlang\;--- Modulo]\label{ex:modenriched}\rule{3mm}{0mm}
\begin{center}
  \begin{tabular}{rl}
    \texttt{1.} & $\commprefix{\mathtt{server}}{var}{\mathtt{client}}{\mathit{x}}{}$; \\
    \texttt{2.} & $\letin{\mathit{v}@\mathtt{client} = \HOLConst{StrOf}\;((\HOLConst{NumOf}\;(\HOLConst{Var}\;\HOLFreeVar{x}))\;\HOLConst{Mod}\;(\HOLConst{Var}\;\HOLFreeVar{y}))}{}$ \\
    \texttt{3.} & $\commprefix{\mathtt{client}}{v}{\mathtt{server}}{\mathit{result}}{}$; \\
  \end{tabular}
\end{center}
\end{example}

To summarise, this thesis provides three main contributions. 
\begin{itemize}
  \item The first contribution is \richerlang, a simply typed lambda calculus with rich types.
  Following the approach taken by \cite{owens2016functional}, we use a functional big-step semantics with
  environments and closures to ensure the evaluation function for \richerlang'\; expressions is total. Our evaluation 
  strategy is call-by-value. We also provide a typing system and give type soundness proof for 
  the proposed semantics and typing rules. \richerlang\; is implemented using the higher-order logic
  proof assistant HOL4 \citep{slind2008brief} and all the proofs are conducted within HOL4.
 
  \item The second contribution is the strong normalization proof for \richerlang. We follow the 
  standard practice for proving strong normalization in simply typed lambda calculus, 
  with a specific case for function closure in the definition of the strong normalization relation.

  \item The third contribution is Kalas enriched with \richerlang. Besides common data types such as 
  integer, string, and boolean, we also add function, pair, and sum types to the local computation in 
  Kalas. Common operators for our data types are included, such as addition, modulo, and negation.
  Integer-string conversion is implemented as well for the integration with Kalas. Last but not least, 
  we prove the enriched Kalas enjoys an important property: \emph{progress}. We also show type preservation holds for non-recursive, 
  synchronous transitions in the enriched Kalas.
\end{itemize}

% - Thesis Structure
